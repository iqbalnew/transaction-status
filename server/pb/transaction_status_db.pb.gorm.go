package pb

import (
	context "context"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	strings "strings"
	time "time"
)

type TemplatesORM struct {
	CompanyId         uint64
	CompanyName       string
	CreatedBy         string
	CreatedDt         *time.Time
	ProcessId         string
	RawUserData       string
	StatusDescription string
	StatusId          int32
	TemplateId        uint64
	UpdatedBy         string
	UpdatedDt         *time.Time
}

// TableName overrides the default tablename generated by GORM
func (TemplatesORM) TableName() string {
	return "templates"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Templates) ToORM(ctx context.Context) (TemplatesORM, error) {
	to := TemplatesORM{}
	var err error
	if prehook, ok := interface{}(m).(TemplatesWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.TemplateId = m.TemplateId
	to.ProcessId = m.ProcessId
	to.CompanyId = m.CompanyId
	to.CompanyName = m.CompanyName
	to.StatusId = int32(m.StatusId)
	to.StatusDescription = m.StatusDescription
	to.RawUserData = m.RawUserData
	to.CreatedBy = m.CreatedBy
	if m.CreatedDt != nil {
		t := m.CreatedDt.AsTime()
		to.CreatedDt = &t
	}
	to.UpdatedBy = m.UpdatedBy
	if m.UpdatedDt != nil {
		t := m.UpdatedDt.AsTime()
		to.UpdatedDt = &t
	}
	if posthook, ok := interface{}(m).(TemplatesWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TemplatesORM) ToPB(ctx context.Context) (Templates, error) {
	to := Templates{}
	var err error
	if prehook, ok := interface{}(m).(TemplatesWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.TemplateId = m.TemplateId
	to.ProcessId = m.ProcessId
	to.CompanyId = m.CompanyId
	to.CompanyName = m.CompanyName
	to.StatusId = Status(m.StatusId)
	to.StatusDescription = m.StatusDescription
	to.RawUserData = m.RawUserData
	to.CreatedBy = m.CreatedBy
	if m.CreatedDt != nil {
		to.CreatedDt = timestamppb.New(*m.CreatedDt)
	}
	to.UpdatedBy = m.UpdatedBy
	if m.UpdatedDt != nil {
		to.UpdatedDt = timestamppb.New(*m.UpdatedDt)
	}
	if posthook, ok := interface{}(m).(TemplatesWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Templates the arg will be the target, the caller the one being converted from

// TemplatesBeforeToORM called before default ToORM code
type TemplatesWithBeforeToORM interface {
	BeforeToORM(context.Context, *TemplatesORM) error
}

// TemplatesAfterToORM called after default ToORM code
type TemplatesWithAfterToORM interface {
	AfterToORM(context.Context, *TemplatesORM) error
}

// TemplatesBeforeToPB called before default ToPB code
type TemplatesWithBeforeToPB interface {
	BeforeToPB(context.Context, *Templates) error
}

// TemplatesAfterToPB called after default ToPB code
type TemplatesWithAfterToPB interface {
	AfterToPB(context.Context, *Templates) error
}

// DefaultCreateTemplates executes a basic gorm create call
func DefaultCreateTemplates(ctx context.Context, in *Templates, db *gorm.DB) (*Templates, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TemplatesORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TemplatesORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TemplatesORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TemplatesORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskTemplates patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTemplates(ctx context.Context, patchee *Templates, patcher *Templates, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Templates, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedDt bool
	var updatedUpdatedDt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"TemplateId" {
			patchee.TemplateId = patcher.TemplateId
			continue
		}
		if f == prefix+"ProcessId" {
			patchee.ProcessId = patcher.ProcessId
			continue
		}
		if f == prefix+"CompanyId" {
			patchee.CompanyId = patcher.CompanyId
			continue
		}
		if f == prefix+"CompanyName" {
			patchee.CompanyName = patcher.CompanyName
			continue
		}
		if f == prefix+"StatusId" {
			patchee.StatusId = patcher.StatusId
			continue
		}
		if f == prefix+"StatusDescription" {
			patchee.StatusDescription = patcher.StatusDescription
			continue
		}
		if f == prefix+"RawUserData" {
			patchee.RawUserData = patcher.RawUserData
			continue
		}
		if f == prefix+"CreatedBy" {
			patchee.CreatedBy = patcher.CreatedBy
			continue
		}
		if !updatedCreatedDt && strings.HasPrefix(f, prefix+"CreatedDt.") {
			if patcher.CreatedDt == nil {
				patchee.CreatedDt = nil
				continue
			}
			if patchee.CreatedDt == nil {
				patchee.CreatedDt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedDt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedDt, patchee.CreatedDt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedDt" {
			updatedCreatedDt = true
			patchee.CreatedDt = patcher.CreatedDt
			continue
		}
		if f == prefix+"UpdatedBy" {
			patchee.UpdatedBy = patcher.UpdatedBy
			continue
		}
		if !updatedUpdatedDt && strings.HasPrefix(f, prefix+"UpdatedDt.") {
			if patcher.UpdatedDt == nil {
				patchee.UpdatedDt = nil
				continue
			}
			if patchee.UpdatedDt == nil {
				patchee.UpdatedDt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedDt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedDt, patchee.UpdatedDt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedDt" {
			updatedUpdatedDt = true
			patchee.UpdatedDt = patcher.UpdatedDt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTemplates executes a gorm list call
func DefaultListTemplates(ctx context.Context, db *gorm.DB) ([]*Templates, error) {
	in := Templates{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TemplatesORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TemplatesORM{}, &Templates{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TemplatesORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []TemplatesORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TemplatesORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Templates{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TemplatesORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TemplatesORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TemplatesORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TemplatesORM) error
}
